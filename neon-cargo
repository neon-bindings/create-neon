#!/usr/bin/env node

"use strict";

const { spawn } = require("child_process");
const { dirname } = require("path");
const { copyFile, mkdir } = require("fs");
const readline = require("readline");

const CARGO = process.env.CARGO || "cargo";

// Split arguments between ones targeting neon-cargo and cargo
const [neonCargoArgs, cargoArgs] = splitArgs(process.argv.slice(2));
const config = parseNeonCargoArgs(neonCargoArgs);

// Determine if the user is executing a cargo build
const cargoSubcommand = cargoArgs.find(arg => !arg.startsWith("-"));
const isCargoBuild = ["build", "b"].includes(cargoSubcommand);

if (isCargoBuild) {
    cargoBuild();
} else {
    cargoPassthrough();
}

// Not a cargo build, pass through the command
function cargoPassthrough() {
    spawn(CARGO, cargoArgs, {
        stdio: "inherit",
    });
}

function processCargoBuildLine(line) {
    const data = JSON.parse(line);

    if (data.reason !== 'compiler-artifact') {
        return;
    }

    const outputFile = config.outputFiles[data.target.name];
    const filename = data.filenames[0];

    if (!outputFile || !filename) {
        return;
    }

    mkdir(dirname(outputFile), { recursive: true }, (err) => {
        if (err) {
            return console.error(err);
        }

        copyFile(filename, outputFile, (err) => {
            if (err) {
                console.error(err);
            }
        });
    });
}

function cargoBuild() {
    const hasCustomMessageFormat = doArgsInclude(cargoArgs, "--message-format");
    const [first, second] = splitArgs(cargoArgs);
    const args = hasCustomMessageFormat
        ? cargoArgs
        : [...first, "--message-format=json-render-diagnostics", ...second];    

    const cargo = spawn(CARGO, args, {
        stdio: ["inherit", "pipe", "inherit"]
    });

    if (hasCustomMessageFormat) {
        cargo.stdout.pipe(process.stdout);
    }

    const rl = readline.createInterface({ input: cargo.stdout });

    rl.on("line", processCargoBuildLine);
}

function splitArgs(args) {
    const splitAt = args.indexOf("--");
    const first = splitAt < 0 ? args : args.slice(0, splitAt);
    const second = splitAt < 0 ? [] : args.slice(splitAt + 1);

    return [first, second];
}

function doArgsInclude(args, param) {
    if (args.includes(param)) {
        return true;
    }

    return args.some(arg => arg.startsWith(`${param}=`));
}

function printUsage() {
    console.error("Expected arguments: -o [target]=[output]");
    process.exit(-1);
}

function parseNeonOutputArg(arg) {
    if (!arg) {
        return printUsage();
    }

    const splitAt = arg.indexOf("=");
    const target = arg.slice(0, splitAt);
    const output = arg.slice(splitAt + 1);

    if (splitAt < 0 || !target || !output) {
        return printUsage();
    }

    return { target, output };
}

function parseNeonCargoArgs(args) {
    const outputFiles = args
        .map((arg, i, arr) => [arg, arr[i + 1]])
        .filter(([arg]) => arg === "-o")
        .map(([, arg]) => parseNeonOutputArg(arg))
        .reduce((acc, { target, output }) => Object.assign(acc, {
            [target]: output
        }), {});

    return { outputFiles };
}
